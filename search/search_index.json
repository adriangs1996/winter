{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#wintry-a-web-framework-for-you-the-developer-in-a-clean-way-a-cool-way-build-apps-with-speed-and-ease-with-the-power-of-the-winter-at-your-side","title":"Wintry: A Web Framework for you, the developer, in a clean way, a cool way. Build apps with speed and ease, with the power of the winter at your side.","text":"<p>Hello, friend, welcome to Wintry. You may have stumble with this project searching for a python web framework, well, you got what you want.</p> <p>Pherhaps you know many other frameworks, pherhaps you know Django, or maybe Flask, or hopefully FastAPI. And odds are that you are willing to take a new project for a ride with a new alternative. Well, Wintry is this, your new alternative, one that do not push you out of your confort zone, but do not take the \"written before\" path.</p> <p>Beign accured, if you have used FastAPI, you would feel at home, Wintry is heavilly inspired in FastAPI, it actually uses it whenever it can. But it add a bunch of  'cool' stuff on top.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install wintry\n\n---&gt; 100%\n</code></pre> <p>Let's see what Wintry looks like:</p> app.py<pre><code>from wintry.controllers import controller, get\nfrom wintry import App\nfrom wintry.settings import WinterSettings\n\n@controller\nclass MarvelController:\n\n    @get('')\n    async def hello_world(self):\n        return \"Hello World\"\n\nsettings = WinterSettings()\napi = App(settings)\n</code></pre> <p>Yeap, is that easy to build an API, self documented, everything that you would expect from a FastAPI based framework, but already you can see some perks:</p> <ul> <li> <p>A different rounting system (Class Based)</p> </li> <li> <p>The hability to use methods as endpoints, just as you would in more traditional frameworks like .NET Core or NestJS</p> </li> <li> <p>An API Factory, which automatically recognizes your controller, and register it.</p> </li> </ul> <p>Wintry aims to provide a lot of things, and at the very least, it ease the process of writting FastAPI endpoints. But we are just scratching the surface here, this is the tip of the Iceberg. Grab your cough, make a hot coffee, and embrace the 'cool', because winter is comming and this penguin framework would prepare you for it.</p> <p>Besides all that, Wintry is fully build with type-annotations, which make a developer's editor best friend.</p>"},{"location":"#run-it","title":"Run it","text":"<pre><code>$ uvicorn app:api --reload\n\nINFO:     Uvicorn running on http://localhost:8000 (Press CTRL+C to quit)\nINFO:     Started reloader process [124387] using statreload\nINFO:     Started server process [124390]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n</code></pre>"},{"location":"#check-it","title":"Check it","text":"<p>Go to http://localhost:8000/marvel and you should see:</p> <pre><code>\"Hello World\"\n</code></pre>"},{"location":"#interactive-api-docs","title":"Interactive API docs","text":"<p>Go to http://localhost:8000/docs</p> <p>You will see the automatic API Documentation, just as like you are used from FastAPI:</p> <p></p>"},{"location":"#contributions","title":"Contributions","text":"<p>Every single contribution is very appreciated. From ideas, issues, PR, criticism, anything you can imagine.</p> <p>If you are willing to provide a PR for a feature, just try to give at least some tests for the feature, I try my best mantaining a pool of tests that will be growing with time</p> <ul> <li> <p>Issue Tracker</p> </li> <li> <p>Fork the repo, change it, and make a PR</p> </li> </ul>"},{"location":"#thanks","title":"Thanks","text":"<p>To @tiangolo for the amazing SQLModel and FastAPI</p> <p>To the amazing Django Team</p> <p>To the Spring Project and NestJS for such amazing frameworks</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License</p>"},{"location":"quickstart/","title":"Quick Start","text":"<p>Here you will find a gentle introduction to \ud83d\udc27Wintry\ud83d\udc27. No in-deep API discussion or details related to every specific possible combination of settings. Instead you will be able to grasp the full power of \ud83d\udc27Wintry\ud83d\udc27 through a textbook-like tutorial over an imaginary APP which will allow me to show you the approaches that lead to the creation of \ud83d\udc27Wintry\ud83d\udc27 and how easy is to build 'cool stuff' with it. We have a long road ahead, let's get started!.</p>"},{"location":"quickstart/#the-demo","title":"The demo","text":"<p>\ud83d\udc4b Hello there. Whether you are a newbie or a seassoned developer, you are at the right place. You will develop a full CRUD app, from scratch, using \ud83d\udc27Wintry\ud83d\udc27 to ease your development flow. You'll find that the framework tries to remove the hazzle of setting up your environment, and let you instead focus on what really matters, your business logic.</p> <p>Pherhaps a lot of what you will see next feels like magic \ud83e\uddd9\u200d\u2642\ufe0f, that's ok, a lot of what \ud83d\udc27Wintry\ud83d\udc27 do under the hood is pretty advanced stuff, but rest assure, it is developed with speed \ud83d\ude80, performance, and confort in mind. Also, I expect you to find it really, really cool \ud83e\udd76</p> <p>This demo follows the same road of this book\ud83d\udcda, which I personally love. The API design is Domain Model centric, and I think that it always should be. This means that we will try to do DDD, in the right way, with as little (or none) details from data access as possible, and using our Domain Models for every interaction and Domain Logic. I will jump over most Design choices and dive directly in the implementation.</p> <p>Think in your business logic first</p> <p>We\u2019ve found that many developers, when asked to design a new system, will immediately start to build a database schema, with the object model treated as an afterthought. This is where it all starts to go wrong. Instead, behavior should come first and drive our storage requirements. After all, our customers don\u2019t care about the data model. They care about what the system does; otherwise they\u2019d just use a spreadsheet.</p> <p>Suppose we are working for a furniture retailer, and now we are concerned with the allocation system. Some rules are:</p> <ul> <li> <p>We need to allocate order lines to batches. When we\u2019ve allocated an order line to a batch, we will send stock from that specific batch to the customer\u2019s delivery address. When we allocate x units of stock to a batch, the available quantity is reduced by x.</p> </li> <li> <p>We can\u2019t allocate to a batch if the available quantity is less than the quantity of the order line</p> </li> <li> <p>We can\u2019t allocate the same line twice</p> </li> </ul> <p>The following class definitions could represent an Aggregate for consinstency and boundaries checks.</p> <p>Tip</p> <p>An AGGREGATE is a cluster of associated objects that we treat as a unit for the purpose of data changes.</p> models.py<pre><code>from datetime import date\nfrom wintry.models import Array, Model, RequiredId\n\nclass OutOfStock(Exception):\n    pass\n\nclass OrderLine(Model):\n    sku: str\n    qty: int\n    orderid: str = RequiredId()\n\nclass Batch(Model):\n    sku: str\n    purchased_quantity: int\n    reference: str = RequiredId()\n    allocations: list[OrderLine] = Array()\n    eta: date | None = None\n\n    def allocate(self, line: OrderLine):\n        if self.can_allocate(line):\n            self.allocations.append(line)\n\n    def deallocate(self, line: OrderLine):\n        if line in self.allocations:\n            self.allocations.remove(line)\n\n    def deallocate_one(self) -&gt; OrderLine:\n        return self.allocations.pop()\n\n    @property\n    def allocated_quantity(self) -&gt; int:\n        return sum(line.qty for line in self.allocations)\n\n    @property\n    def available_quantity(self) -&gt; int:\n        return self.purchased_quantity - self.allocated_quantity\n\n    def can_allocate(self, line: OrderLine) -&gt; bool:\n        return self.sku == line.sku and self.available_quantity &gt;= line.qty\n\n    def __gt__(self, other):\n        if self.eta is None:\n            return False\n        if other.eta is None:\n            return True\n        return self.eta &gt; other.eta\n\nclass Product(Model):  # (1)\n    sku: str = RequiredId()  # (2)\n    batches: list[Batch] = Array()\n\n    def allocate(self, line: OrderLine) -&gt; str | None:\n        try:\n            batch = next(b for b in sorted(self.batches) if b.can_allocate(line))\n            batch.allocate(line)\n            return batch.reference\n        except StopIteration:\n            return None\n\n    def change_batch_quantity(self, ref: str, qty: int):\n        batch = next(b for b in self.batches if b.reference == ref)\n        batch.purchased_quantity = qty\n        while batch.available_quantity &lt; 0:\n            line = batch.deallocate_one()\n            yield line\n</code></pre> <ol> <li>Models are transformed to dataclasses, so no need to define a dummy constructor.</li> <li><code>sku</code> is the identifier of this model.</li> </ol> <p>Models are automatically converted to dataclasses. Futhermore, we can now build instances of our models using <code>Batch.build()</code> or serialize them using <code>Batch.to_dict()</code></p> <p>Notice that we define the models interaction inside the model itself, don't worry about persistance, we will see that in a moment. First, let's tackle an issue that is not   appearent when first starting the app's development, but this is a tutorial, and I'm allowed to cheat and go with time travel\u231b. The issues is \"Query Segregation\". Wait, WTF you just say. Is easy, usually when we develop an app, we try to model two things at the same time: Relations and Representations. We always want our Relations to be consistent, we want our representations to be efficient. Translating to code, I want to represent <code>Batch</code> allocations as a list, because is easy to remove or add new <code>OrderLines</code>, and to easily and accuratly compute <code>available_quantity</code> and <code>allocated_quantity</code>. But when I query the system, I don't expect it to search to an entire array for an <code>Allocation</code>, it would be better if this query is optimized too. The problem is, we should split our model into \"Write Data\" and \"Read Data\", and there is a pattern that really apply here: CQRS:</p> <p>Note</p> <p>I'm not using Event-Sourcing here, usually comes together\ud83d\udc6a, but we should not confuse one with the other.</p> viewmodels.py<pre><code>from wintry.generators import AutoString\nfrom wintry.models import Id, Model\n\nclass AllocationsViewModel(Model):\n    id: str = Id(default_factory=AutoString)\n    orderid: str\n    sku: str\n    batchref: str\n</code></pre> <p>I know I said we will not be concerned with data access at the moment, but the real benefit of this split comes when we are querying a DB: we are eliminating the joins from the query.</p> <p>Ok, we have run from our persistance layer for a long time, let's tackle that next.</p>"},{"location":"quickstart/#one-aggregate-one-repository","title":"One Aggregate = One Repository","text":"<p>This is by no means enforced, but it is a good rule of thumb. Thinking in Repositories at Aggregates levels allows to simplify data access logic at the same time you guarantee some degree of  cohesion between dependant models. Again, I follow this approach as in the book \ud83d\udcda, but it is here just to make a point.</p> <p>Repositories are abstractions over Data\ud83d\uddc3\ufe0f Access, that allow us to treat databases as if we were controlling an in-memory data store. Usually Repositories are coupled to databases with a  specific dialect. \ud83d\udc27Wintry\ud83d\udc27 provides a unified view over data\ud83d\uddc3\ufe0f access, but not the same way as Django. Django Model's Managers  represent what is called an Active Record, and that aproach promotes the \"Fat Models\" antipattern. Well, is all a matter of opinions, but there is always one friction:</p> <p>Writting Queries for managing domain logic usually involve pretty straight forward queries, specially for writting data\ud83d\uddc3\ufe0f.</p> <p>So, with \ud83d\udc27Wintry\ud83d\udc27 , you dont have to write your Queries at all, you can do it, though you most likely wont need it. Sounds\ud83d\udd0a confusing, let me show you how our persistance layer could look like:</p> repositories.py<pre><code>from tuto.viewmodels import AllocationsViewModel\nfrom wintry.ioc import provider\nfrom wintry.repository import Repository, query\nfrom .models import Product\n\n@provider # (3)\nclass ProductRepository(Repository[Product, str], entity=Product):\n    @query\n    async def get_by_sku(self, *, sku: str) -&gt; Product | None:\n        ... # (1)\n\n    @query\n    async def get_by_batches__reference(\n        self, *, batches__reference: str\n    ) -&gt; Product | None:\n        ...\n\n@provider\nclass AllocationViewModelRepository(\n    Repository, entity=AllocationsViewModel, for_backend=\"mongo\" # (2)\n):\n    @query\n    async def find_by_orderid(self, *, orderid: str) -&gt; list[AllocationsViewModel]:\n        ...\n\n    @query\n    async def delete_by_orderid_and_sku(self, *, orderid: str, sku: str):\n        ...\n</code></pre> <ol> <li>\ud83e\uddd9\u200d\u2642\ufe0fHey dude, you forgot to implement your method, this will crush you in your face.... Well, no it didn't... BAZINGA!!\ud83e\uddd9\u200d\u2642\ufe0f</li> <li>\u2699\ufe0fDo not give to much thinking to this, it would be explained in the Repository Chapter.</li> <li>\ud83d\udc89This comes from the dependency injection module, it allows to latter on inject instances of this class</li> </ol> <p>So you may ask: Ok, where are all these methods implemented?</p> <p>That's the beauty, yo don't have to, it is already there, in the name. Repositories are query compilers and automatically translate your method names into queries, and yes, it automatically knows how to build your object from your data source, and whether to return a list or a single object.</p> <p>Speaking of data source, we better configure one to make the whole thing real, right? We will be using Postgresql, Mongo and Redis for this tutorial, but any SQLAlchemy compatible database will do. Do you remember when we talked  about data separation? Well, \ud83d\udc27Wintry\ud83d\udc27 allow us to do that at persistance layer very very easily too.  For the setup, we can use Docker with the following docker-compose:</p> docker-compose.yml<pre><code>services:\n  postgres:\n    container_name: postgres\n    image: postgres:14-alpine\n    ports:\n      - \"5432:5432\"\n    environment:\n      - POSTGRES_PASSWORD=secret\n      - POSTGRES_USER=postgres\n      - POSTGRES_DB=tests\n\n  mongo:\n    container_name: mongo\n    image: mongo:5.0.6-focal\n    ports:\n      - \"27017:27017\"\n    restart: always\n    volumes:\n      - ./scripts/rs-init.sh:/scripts/rs-init.sh\n    entrypoint:\n      [\n        \"/usr/bin/mongod\",\n        \"--bind_ip_all\",\n        \"--replSet\",\n        \"dbrs\"\n      ]\n\n  redis:\n    container_name: redis\n    image: redis:6-alpine\n    ports:\n      - \"6379:6379\"\n    restart: always\n</code></pre> <pre><code>$ docker compose up -d\n\n[+] Running 5/5\n \u283f Network winter_default Created                                                                                                      0.4s\n \u283f Container postgres      Started                                                                                                      8.5s\n \u283f Container redis         Started                                                                                                      8.7s\n \u283f Container mongo         Started                                                                                                      6.5s\nStarting replica set initialization\nConnecting to:          mongodb://mongo:27017/?directConnection=true&amp;appName=mongosh+1.3.1\nMongoNetworkError: connect ECONNREFUSED 172.22.0.2:27017\nCurrent Mongosh Log ID: 62803fdacc3f016a401c7b6f\nConnecting to:          mongodb://mongo:27017/?directConnection=true&amp;appName=mongosh+1.3.1\nUsing MongoDB:          5.0.6\nUsing Mongosh:          1.3.1\n\nFor mongosh info see: https://docs.mongodb.com/mongodb-shell/\n\n\nTo help improve our products, anonymous usage data is collected and sent to MongoDB periodically (https://www.mongodb.com/legal/privacy-policy).\nYou can opt-out by running the disableTelemetry() command.\n\n------\n   The server generated these startup warnings when booting:\n   2022-05-14T23:48:28.619+00:00: Using the XFS filesystem is strongly recommended with the WiredTiger storage engine. See http://dochub.mongodb.org/core/prodnotes-filesystem\n   2022-05-14T23:48:32.745+00:00: Access control is not enabled for the database. Read and write access to data and configuration is unrestricted\n   2022-05-14T23:48:32.745+00:00: You are running this process as the root user, which is not recommended\n------\n\nwaited for connection\n\nConnection finished\nCreating replica set\nCurrent Mongosh Log ID: 62803fe159c7cb9bf4f581bd\nConnecting to:          mongodb://mongo:27017/?directConnection=true&amp;appName=mongosh+1.3.1\nUsing MongoDB:          5.0.6\nUsing Mongosh:          1.3.1\n\nFor mongosh info see: https://docs.mongodb.com/mongodb-shell/\n\n------\n   The server generated these startup warnings when booting:\n   2022-05-14T23:48:28.619+00:00: Using the XFS filesystem is strongly recommended with the WiredTiger storage engine. See http://dochub.mongodb.org/core/prodnotes-filesystem\n   2022-05-14T23:48:32.745+00:00: Access control is not enabled for the database. Read and write access to data and configuration is unrestricted\n   2022-05-14T23:48:32.745+00:00: You are running this process as the root user, which is not recommended\n------\n\ntest&gt; {\n  ok: 1,\n  '$clusterTime': {\n    clusterTime: Timestamp({ t: 1652572133, i: 1 }),\n    signature: {\n      hash: Binary(Buffer.from(\"0000000000000000000000000000000000000000\", \"hex\"), 0),\n      keyId: Long(\"0\")\n    }\n  },\n  operationTime: Timestamp({ t: 1652572133, i: 1 })\n}\ndbrs [direct: secondary] test&gt; replica set created \n</code></pre> <p>Tip</p> <p>All the output of the above console is necessary to show you that you need to configure the mongodb server as a replica set because that's the only way to use sessions. You can configure yours with the following script, this is the one used in the docker-compose file from above rs-init.sh<pre><code>    #!/bin/bash\n\n    echo \"Starting replica set initialization\"\n    until mongosh --host mongo --eval \"print(\\\"waited for connection\\\")\"\n    do\n    sleep 2\n    done\n\n    echo \"Connection finished\"\n    echo \"Creating replica set\"\n\n    MONGO1IP=$(getent hosts mongo | awk '{ print $1 }')\n\n    read -r -d '' CMD &lt;&lt;EOF\n    var config = {\n        \"_id\": \"dbrs\",\n        \"version\": 1,\n        \"members\": [\n            {\n                \"_id\": 1,\n                \"host\":'${MONGO1IP}:27017',\n            }\n        ]\n    };\n    rs.initiate(config, { force: true });\n    EOF\n\n    echo $CMD | mongosh --host mongo\n    echo \"replica set created\"\n</code></pre></p> <p>Alright, we now need to define the interaction of our app, the way our Models talks one to another. We will do it in a Event-Based fashion. In fact, we will write our service layer in a way that will transform our app into a Message Pipeline.</p>"},{"location":"quickstart/#first-thing-first-ensure-atomicity-and-consistency-use-an-unitofwork","title":"First thing First, ensure atomicity and consistency, use an UnitOfWork","text":"<p>Out of the box, \ud83d\udc27Wintry\ud83d\udc27 integrates an Unit Of Work with your Repositories, let's declare one for our app:</p> uow.py<pre><code>from wintry.transactions import UnitOfWork as WintryUnitOfWork\nfrom wintry.ioc import provider\nfrom .repositories import ProductRepository\n\n@provider\nclass UnitOfWork(WintryUnitOfWork):\n    products: ProductRepository\n\n    def __init__(self, products: ProductRepository) -&gt; None:\n        super().__init__(products=products)\n</code></pre> <p>The Unit of Work pattern</p> <p>The Unit of Work pattern is used to group one or more operations (usually database CRUD operations) into a single transaction or \u201cunit of work\u201d so that all operations either pass or fail as one unit. In simple words we can say that for a specific user action, say booking on a website, all the transactions like insert/update/delete and so on are done in one single transaction, rather than doing multiple database transactions. This means, one unit of work here involves insert/update/delete operations, all in one single transaction so that all operations either pass or fail as one unit.</p> <p>Yes, thats all it takes. But how we use this?? If you read the idea of \"Unit of Work\", you probably associate it with a lovely piece of python syntax: a context manager. That's how we use it, we enclose our transaction inside a context manager and then commit the changes when we have done. If the transaction fails for some reason, then the changes are rolled back. That could look like this:</p> <pre><code>    async with self.uow as uow:\n        product = await uow.products.get_by_sku(sku=line.sku)\n        if product is None:\n            raise InvalidSku(f\"Invalid sku {line.sku}\")\n\n        batchref = product.allocate(line)\n        if batchref is not None:\n            self.register(\n                Allocated(orderid=line.orderid, sku=line.sku, qty=line.qty, batchref=batchref)\n            )\n            self.logger.info(f\"Allocated {line}\")\n        else:\n            self.register(OutOfStockEvent(sku=line.sku))\n\n        await uow.commit()\n</code></pre> <p>This is really nice, but can you see something there? Repeating the context manager for each transaction is quite cumbersome. Futhermore, our  Unit of Work class can only handle a single type of repository (More on this on the  Repositories section). For common use case like this, \ud83d\udc27Wintry provides another shortcut: the <code>@transaction</code> decorator. Let's see how we can use all this in our service layer.</p>"},{"location":"quickstart/#the-service-layer","title":"The service layer","text":"<p>Service layers allows to decouple the business logic from storage requirements. Actually, I like to think in services as if I were coding a transient app (Meaning that it gets data from memory and so, can use all sort of <code>Python</code> representations and operate directly on the model intances). This is actually a pretty powerfull concept, as applications tend to become complex at the Domain Level, where restrictions and relations are enforced. Also, services usually are represented in terms of verbs, that represent a desired action to be executed by our system. This concept of action is what give the name to the <code>Command</code> input that you will see in every service function. So, our service layer could look like this:</p> services.py<pre><code>from logging import Logger\nfrom tuto.publisher import Publisher\nfrom tuto.repositories import AllocationViewModelRepository, ProductRepository\nfrom tuto.viewmodels import AllocationsViewModel\nfrom wintry.mqs import event_handler, command_handler, MessageQueue\nfrom wintry.ioc import provider\nfrom commands import Allocate, ChangeBatchQuantity, CreateBatch\nfrom models import Batch, OrderLine, Product\nfrom events import Allocated, Deallocated, OutOfStock as OutOfStockEvent\nfrom wintry.transactions.transactional import transaction\n\n\nclass InvalidSku(Exception):\n    pass\n\n\n@provider\nclass MessageBus(MessageQueue): # (1)\n    products: ProductRepository\n    logger: Logger\n    sender: Publisher # (2)\n    allocations: AllocationViewModelRepository\n\n    @command_handler # (4)\n    @transaction\n    async def allocate(self, command: Allocate):\n        line = OrderLine.build(command.dict())\n        product = await self.products.get_by_sku(sku=line.sku)\n        if product is None:\n            raise InvalidSku(f\"Invalid sku {line.sku}\")\n\n        batchref = product.allocate(line)\n        if batchref is not None:\n            self.register(\n                Allocated(orderid=line.orderid, sku=line.sku, qty=line.qty, batchref=batchref)\n            )\n            self.logger.info(f\"Allocated {line}\")\n        else:\n            self.register(OutOfStockEvent(sku=line.sku))\n\n    @command_handler\n    @transaction\n    async def add_batch(self, command: CreateBatch):\n        product = await self.products.get_by_sku(sku=command.sku)\n        if product is None:\n            product = Product(sku=command.sku)\n            product = await self.products.create(entity=product)\n        product.batches.append(\n            Batch(reference=command.ref, purchased_quantity=command.qty, sku=command.sku, eta=command.eta)\n        )\n\n        self.logger.info(\"Created Batch\")\n\n    @command_handler\n    @transaction\n    async def change_batch_quantity(self, cmd: ChangeBatchQuantity):\n        product = await self.products.get_by_batches__reference(\n            batches__reference=cmd.ref\n        )\n        assert product is not None\n        for line in product.change_batch_quantity(**cmd.dict()):\n            self.register(Deallocated(**line.to_dict()))\n</code></pre> <ol> <li> <p>The <code>MessageQueue</code> will be explained in the Message Pipeline Chapter, but long story short, it will allow you to translate your imperative app into a reactive pipeline of commands and events.  You declare handlers for commands and events, and they will get fired\ud83d\ude80 by the <code>MessageQueue</code> at the right input.</p> </li> <li> <p>Use Dependency Injection for a Publisher interface, we will get to the implementation in short. It just forward events to redis.</p> </li> <li> <p>Our Unit Of Work implementation, injected by the Dependency Injection System.</p> </li> <li> <p>Register a handler for the <code>Allocate</code> command. Commands are just pydantic models and usually they are used as inputs in controllers.</p> </li> </ol> <p>There is a lot going on there, but notice something: we are never calling the <code>Repository.update()</code> method, we just call functions over model instances that manage the state of the instance and its relations with other models. And notice that we do all this inside a function decorated with  <code>@transaction</code>. Long story short, <code>@transaction</code> will initialize the repositories of the <code>MessageBus</code> class and issue a commit at the end of the function if everything went well. You should be scratching your head right now, because, I mean, this can not work, right ??!! Well, it does, and actually is not even thanks to \ud83d\udc27Wintry\ud83d\udc27 (at least not entirely) because in here, we are using the full power of SQLAlchemy sessions to achieve this effect. The cool\ud83d\ude0e part, and when \ud83d\udc27Wintry\ud83d\udc27 becomes a really powerfull tool for this endeavor, is that it doesnt matter if you change to use MongoDB as your primary DB (a NOSQL one), it will provide you with the same features of automatic model synchronization. Futhermore, look at how clean the implementation of the services is, and of course, testability is achieved with so many components decoupled and used through Dependency Injection\ud83d\udc89.</p> <p>About Models</p> <p>If you ever have used Vue.js in the past, the idea with reactive models is somehow similar as how <code>refs</code> work in Vue.js. Behind the scenes, \ud83d\udc27Wintry\ud83d\udc27 is converting your model instances into Proxy Objects (either with SQLAlchemy sessions, or with \ud83d\udc27Wintry\ud83d\udc27 builtin tracker) that record when a change is made to one of their properties, issuing an update for that property when the <code>uow.commit()</code> is called. Of course, this means that this functionality is only available if repositories are linked with an UnitOfWork class, if used standalone, they must call <code>Repository.update()</code> on the required instances.</p> <p>Perhaps you are curious about the <code>self.register()</code> function that every service is calling. Well this is the way of the Message Pipeline to comunicate that something happened. This are called <code>Events</code>. For example, when we succesfuly allocate an orderline, we register the <code>Allocated</code> event, which is schedulled for triggering in the Message Pipeline.</p> <p>But firing\ud83d\ude80 events is not useful if we do not supply handlers for them, right?</p> services.py<pre><code># ... Rest of the code of the service layer\n    @event_handler\n    async def reallocate(self, event: Deallocated):\n        product = await self.products.get_by_sku(sku=event.sku)\n        self.register(Allocate(**event.dict()))\n\n    @event_handler\n    async def save_allocation_view(self, event: Allocated):\n        allocation = AllocationsViewModel(**event.dict(exclude={\"qty\"}))\n        allocation = await self.allocations.create(entity=allocation)\n        await self.sender.send(\"line_allocated\", allocation.to_dict())\n        self.logger.info(\"Synced Allocation View\")\n\n    @event_handler\n    async def delete_allocation_view(self, event: Deallocated):\n        await self.allocations.delete_by_orderid_and_sku(\n            orderid=event.orderid, sku=event.sku\n        )\n        self.logger.info(\n            f\"Deallocated orders with: orderid={event.orderid}, sku={event.sku}\"\n        )\n</code></pre> <p>Again, really clean and concise implementation thanks to all the help of the framework. And notice a little detail, these are in-house events, meaning that they are fired\ud83d\ude80 and received by the same Entity (The Message Pipeline). This might seem silly at first, because, WTF don't we just put that code right before finishing the service function ???!! Well, this will become clearer in the Events Handlers section, but the thing is that this events can be run even in background, and represent a different logical unit than commands. Remember, we want to follow the Single Responsability principle whenever we can right?</p> <p>Notice that the Deallocated Event has declared two handlers. Yes, you can do that, why?, well, because events can fail, and it is OK if they do, so you wanna split your event logic as most as possible to ensure maximun cohesion in your app. More on this on the Events Section.</p>"},{"location":"quickstart/#external-events","title":"External Events","text":"<p>Notice that we use the <code>Publisher.send()</code> here, but we have not implemented that yet, so let's do that:</p> publisher.py<pre><code>import json\nfrom typing import Protocol\nfrom wintry.ioc import provider\nimport aioredis\n\nclass Publisher(Protocol):\n    async def send(self, channel: str, data: dict):\n        ...\n\n@provider(of=Publisher) # (1)\nclass RedisPublisher(Publisher):\n    def __init__(self) -&gt; None:\n        self.client = aioredis.from_url(\"redis://localhost\")\n\n    async def send(self, channel: str, data: dict):\n        await self.client.publish(channel, json.dumps(data))\n</code></pre> <ol> <li>\ud83d\ude21\ud83d\ude21Dude, this is brand new</li> </ol> <p>Yeah I know, the <code>@provider(of=Publisher)</code> line, this is how you declare an implementation of an interface, notice that the Publisher class is just a protocol in here. We have defined a RedisPublisher, so we will be sending events to a Redis Channel.</p> <p>This could be useful in a fully Distributed System, as a notification\ud83d\udd14 or synchronization\u23f2\ufe0f mechanism. \ud83d\udc27Wintry\ud83d\udc27 gives you the tools to also easily respond to such events, called external events. Think if you are implementing a Microservice, or maybe your app has been logically split into separated APIS, but that consume the same data source or are  dependent somehow. Well you could use this mechanism to comunicate them. Let's see an example of how we can go about this:</p>"},{"location":"quickstart/#entrypoints","title":"Entrypoints","text":"controllers.py<pre><code>from logging import Logger\nfrom wintry.controllers import microservice, on\nfrom .services import MessageBus\n\n@microservice(TransporterType.redis)\nclass RedisMessagesControllers:\n    logger: Logger\n    messagebus: MessageBus\n\n    @on(\"change_batch_quantity\")\n    async def change_batch_quantity(self, cmd: ChangeBatchQuantity):\n        self.logger.info(f\"Event from Redis: {cmd}\")\n        await self.messagebus.handle(cmd)\n\n    @on(\"line_allocated\")\n    async def line_allocated(self, allocation: AllocationsViewModel):\n        self.logger.info(f\"Hey look, a line've been allocated from redis: {allocation}\")\n</code></pre> <p>You guessed it, with this in place, we can now listen to the <code>line_allocated</code> and <code>change_batch_quantity</code> redis channels. Notice how we injected a <code>MessageBus</code>\ud83d\ude8c instance and supply the <code>ChangeBatchQuantity</code> command as an entry point to the Message Pipeline.</p> <p>This same idea, is what we will use to conform our System API, so, our controllers will look like this: controllers.py<pre><code>from tuto.viewmodels import AllocationsViewModel\nfrom .views import AllocationReadModel, Views\nfrom .commands import Allocate, CreateBatch\nfrom wintry.controllers import controller, post, get\nfrom .services import InvalidSku, MessageBus\nfrom wintry.responses import DataResponse\nfrom wintry.errors import NotFoundError\n\n@controller(prefix=\"\", tags=[\"Products\"])\nclass ProductsController:\n    messagebus: MessageBus\n    views: Views\n\n    @post(\"/add_batch\", response_model=DataResponse[str])\n    async def add_batch(self, cmd: CreateBatch):\n        await self.messagebus.handle(cmd)\n        return DataResponse[str](data=\"Created Batch\")\n\n    @post(\"/allocate\", response_model=DataResponse[str])\n    async def allocate(self, cmd: Allocate):\n        try:\n            await self.messagebus.handle(cmd)\n            return DataResponse[str](data=\"Allocated\", status_code=202)\n        except InvalidSku as e:\n            return DataResponse(status_code=400, message=str(e))\n\n    @get(\"/allocations/{orderid}\", response_model=DataResponse[list[AllocationReadModel]])\n    async def allocations_view(self, orderid: str):\n        results = await self.views.get_allocations_for(orderid)\n        if not results:\n            raise NotFoundError(f\"{orderid}\")\n\n        return DataResponse(data=results)\n</code></pre></p> <p>You see the pattern here, every component in \ud83d\udc27Wintry\ud83d\udc27 follows a similar pattern:</p> <ul> <li>Declare dependencies.</li> <li>Declare action handlers.</li> <li>Provide an entrypoint for those handlers.</li> </ul> <p>Of course, this is only the tip of the iceberg\ud83e\uddca, but you can already see a little penguin\ud83d\udc27 at the top. This can be a Emperor Penguin\ud83d\udc27, or simply a regular penguin, continue reading and find out.</p>"},{"location":"quickstart/#the-app","title":"The App","text":"<p>So now we have everything we need in place, how do we start it?</p> app.py<pre><code>from logging import Logger\nfrom wintry import App\nfrom wintry.orm import metadata\nfrom wintry import BACKENDS\nfrom wintry.ioc import inject\nfrom wintry.settings import (\n    BackendOptions,\n    ConnectionOptions,\n    TransporterSettings,\n    TransporterType,\n    ConnectionOptions,\n    WinterSettings\n)\n\nsettings = WinterSettings(\n    backends=[\n        BackendOptions(\n            name=\"default\",\n            driver=\"wintry.drivers.pg\",\n            connection_options=ConnectionOptions(\n                url=\"postgresql+asyncpg://postgres:secret@localhost/tests\"\n            ),\n        ),\n        BackendOptions(\n            name=\"mongo\",\n            driver=\"wintry.drivers.mongo\",\n            connection_options=ConnectionOptions(\n                url=\"mongodb://localhost:27017/?replicaSet=dbrs\"\n            ),\n        ),\n    ],\n    transporters=[\n        TransporterSettings(\n            driver=\"wintry.transporters.redis\",\n            service=\"RedisMicroservice\",\n            transporter=TransporterType.redis,\n            connection_options=ConnectionOptions(url=\"redis://localhost\"),\n        )\n    ],\n)\n\napp = App(settings=settings)\n</code></pre> <p>You can now run your app:</p> <pre><code>$ uvicorn tuto.app:app --reload --port 8080\n\nINFO:     Uvicorn running on http://127.0.0.1:8080 (Press CTRL+C to quit)\nINFO:     Started reloader process [1129311] using watchgod\nINFO:     2022-05-28 22:22:35 | Loading module tuto.repositories\nINFO:     2022-05-28 22:22:35 | Loading module tuto.events\nINFO:     2022-05-28 22:22:35 | Loading module tuto.settings\nINFO:     2022-05-28 22:22:35 | Loading module tuto.controllers\nINFO:     2022-05-28 22:22:35 | Loading module tuto.commands\nINFO:     2022-05-28 22:22:35 | Loading module tuto.services\nINFO:     2022-05-28 22:22:35 | Loading module tuto.models\nINFO:     2022-05-28 22:22:35 | Loading module tuto.views\nINFO:     2022-05-28 22:22:35 | Loading module tuto.uow\nINFO:     2022-05-28 22:22:35 | Loading module tuto.viewmodels\nINFO:     2022-05-28 22:22:35 | Loading module tuto.publisher\nINFO:     Started server process [1129313]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n</code></pre> <p>Note</p> <p>The logs come from the autoload functionality, it will be explained latter on. The modules names comes from the test app that is shared with the github repository and it is the same from where I have been using the  source code for the demo.</p>"},{"location":"quickstart/#check-it-out","title":"Check it out","text":"<p>Yo can now access the automatic documentation, got to  http://127.0.0.1:8080/docs, where you should find the swagger:</p> <p></p> <p>Three endpoints do not make justice to what you have acomplished. You effectively:</p> <ul> <li> <p>Defined your pristine Models\ud83d\udcaa and handle business\ud83d\udc68\u200d\ud83d\udcbc logic in them.</p> </li> <li> <p>Created Segregated Repositories for Writing\u270d\ud83c\udffb and Querying\ud83d\udc41\ufe0f\u200d\ud83d\udde8\ufe0f efficiently. You even used two different databases for Write Operations and for Read Operations</p> </li> <li> <p>Made atomic transactions, which translate into data consistency.</p> </li> <li> <p>Communicate with an event broker and react to messages on some channels.</p> </li> <li> <p>Implemented your services in an asynchronous way.</p> </li> <li> <p>Defined your system entrypoints (API) and Model Binded the params into objects with validation (Ok, maybe you missed that part, but I ensure you, it is there)</p> </li> </ul> <p>All that, while working with Postgres and MongoDB databases, without writting a single line of SQL or MQL (Mongo Query Language), without worrying about ForeignKeys, Relations, Columns or stuff like that, using components where you want, when you want, saving Models state as if you where just manipulating objects in memory, listening to a Redis instance, that may as well be a RabbitMQ server and still would be the same, declaring your app's requirements as if you where telling the framework what you need instead of commanding it to do stuffs, at the same time you get automatic documentation of your API and in general unleash the power of FastAPI, and still you have the promise that you haven't see it all, that it just the begining, I mean come on, I think you deserve a coffee\u2615, and \ud83d\udc27Wintry\ud83d\udc27 deserves you to give it a shot\ud83d\udd2b.</p>"},{"location":"user-guide/controllers/","title":"\ud83c\udfaeControllers\ud83c\udfae","text":"<p>In 2003, Martin Fowler published Patterns of Enterprise Application Architecture,  which presented MVC as a pattern where an \"input controller\" receives a request,  sends the appropriate messages to a model object, takes a response from the model object,  and passes the response to the appropriate view for display. So, for  Wintry, we use \ud83c\udfae\"controllers\" to define a software layer that accepts input and converts it to commands  for the model or view.</p> <p>Latter on this tutorial, we will take the term \"commands\" quite literally, but for now, let's get started with controllers.</p>"},{"location":"user-guide/controllers/#introduction","title":"Introduction","text":"<p>This \u26e9\ufe0fsection\u26e9\ufe0f will provide details about how \ud83c\udfaeControllers works, some perks at HTTP requests handling, Model Binding caveats, configurations for the controller, correlation\ud83e\udd1d with other components and some features you can abuse when using controllers. I'll try to not make use of the builtin Dependency Injection\ud83d\udc89 as  that's a general concept that is not specific to this, although there are some specifics in how \ud83c\udfaeControllers and Dependency Injection\ud83d\udc89 works together.</p>"},{"location":"user-guide/controllers/#create-your-first-controller","title":"Create your first controller","text":"<p>\ud83c\udfaeControllers are the way your App will talk to the external world. It is trending\ud83d\udcc8 that applications divide their component in two BIG groups: Back-End and Front-End. Each of this group have different ways of been implemented, and each talk to each other to produce the mayority of the apps we currently know. Well, controllers are your Back-End connectors to your Front-End, or better yet, the interface or contract that you stablish wich your client so it comunicates with that part of your App.</p> <p>Mapping to other frameworks, we can see a \ud83c\udfaeController in  Wintry as a Router in FastAPI or a view + urlpatterns in Django. In fact, under the hood,  Wintry \ud83c\udfaecontrollers are just a FastAPI's Router  derived class with some additional behavior, and the <code>@controller</code> decorator just take a bunch of metadata and inspect the declared methods for creating the Router and register it in the  Wintry's register system.</p> <p>You declare a controller like this:</p> <p><pre><code>from wintry.controllers import controller, get\nfrom wintry import App\nfrom wintry.settings import WinterSettings\n\n@controller\nclass Controller:\n    @get(\"/\")\n    async def hello_world(self):\n        return \"Hello World\"\n\napp = App(WinterSettings(auto_discovery_enabled=False)) # ignore this config for now\n</code></pre> This script is complete and it should run as it is</p> <p>That's it. That's the bare minimum amout of code needed for creating an API. Actually you can do better, but is the same as declaring a single endpoint in FastAPI and I will say that this is the way you should go 99% of the time.</p> <p>Info</p> <p>Through the tutorial, I might just use something like this: <pre><code>from wintry import App\nfrom wintry.settings import WinterSettings\n\napp = App(WinterSettings(auto_discovery_enabled=False))\n\n@app.get('')\nasync def hello_world():\n    return \"Hello World\"\n</code></pre></p> <p>when I'm not interested in exploit <code>@controller</code> functionalities. This is  just for making examples, the \ud83c\udfaeController approach is more powerfull and achieve the same. This is the exact couterpart of FastAPI Hello World</p>"}]}